/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * currentValue.java
 *
 * Created on 31-mar-2010, 18:29:57
 */
package net.ausiasmarch.turnos;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import org.mortbay.jetty.*;
import org.mortbay.jetty.servlet.Context;
import org.mortbay.jetty.servlet.ServletHolder;

/**
 *
 * @author Administrador
 */
public class Turno extends javax.swing.JPanel {

    public static Map<String, Estado> estados = new LinkedHashMap<String, Estado>();
    private static Server server;
    Estado estado;

    static void startSevlet() {
        try {
            int port;
            Properties props = new Properties();
            try {
                props.load(new FileInputStream("turnos.properties"));
                if (props.getProperty("port") != null) {
                    port = Integer.parseInt(props.getProperty("port"));
                } else {
                    port = 8080;
                }
            } catch (IOException ex) {
                port = 8080;
            }

            server = new Server(port);
            Context root = new Context(server, "/", Context.SESSIONS);
            root.addServlet(new ServletHolder(new TurnoServlet()), "/turno");
            server.start();
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    static void stopSevlet() {
        try {
            server.stop();
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    /** Creates new form currentValue */
    public Turno() {
        initComponents();
        estado = new Estado();

    }

    public void start() {

        estados.put(this.getName(), estado);
        setCurrentValue(estado.minValue);
        estado.visible = isVisible();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabelDescription = new javax.swing.JLabel();
        jLabelCurrentValue = new javax.swing.JLabel();

        jPanel1.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        jLabelDescription.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabelDescription.setText("--");

        jLabelCurrentValue.setFont(new java.awt.Font("Tahoma", 0, 200)); // NOI18N
        jLabelCurrentValue.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabelCurrentValue.setText("000");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabelDescription, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 632, Short.MAX_VALUE)
                    .addComponent(jLabelCurrentValue, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 632, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addComponent(jLabelCurrentValue, javax.swing.GroupLayout.DEFAULT_SIZE, 244, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabelDescription, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabelCurrentValue;
    private javax.swing.JLabel jLabelDescription;
    private javax.swing.JPanel jPanel1;
    // End of variables declaration//GEN-END:variables

    /**
     * @return the currentValue
     */
    public int getCurrentValue() {
        return estado.currentValue;
    }

    /**
     * @param currentValue the currentValue to set
     */
    public void setCurrentValue(int currentValue) {
        int old = getCurrentValue();


        if (currentValue > estado.maxValue) {
            estado.currentValue = estado.maxValue;
        } else if (currentValue < estado.minValue) {
            estado.currentValue = estado.minValue;
        } else {
            estado.currentValue = currentValue;
        }

        if (currentValue != old) {
            beep();
            refresh();
        }
    }

    /**
     * @return the maxValue
     */
    public int getMaxValue() {
        return estado.maxValue;
    }

    /**
     * @param maxValue the maxValue to set
     */
    public void setMaxValue(int maxValue) {
        estado.maxValue = maxValue;
        if (getCurrentValue() > maxValue) {
            setCurrentValue(maxValue);
        }
        refresh();
    }

    /**
     * @return the fontSize
     */
    public int getFontSize() {
        return jLabelCurrentValue.getFont().getSize();
    }

    /**
     * @param fontSize the fontSize to set
     */
    public void setFontSize(int fontSize) {
        jLabelCurrentValue.setFont(jLabelCurrentValue.getFont().deriveFont(new Float(fontSize)));
        jLabelDescription.setFont(jLabelDescription.getFont().deriveFont(new Float(fontSize / 4)));
    }

    public void reset() {
        setCurrentValue(estado.minValue);

    }

    public void inc() {
        int newCurrentValue;
        newCurrentValue = getCurrentValue() + 1;
        if (newCurrentValue > estado.maxValue) {
            newCurrentValue = 1;
        }

        setCurrentValue(newCurrentValue);

    }

    public void dec() {
        int newCurrentValue;
        newCurrentValue = getCurrentValue() - 1;
        if (newCurrentValue < estado.minValue) {
            newCurrentValue = estado.maxValue;
        }

        setCurrentValue(newCurrentValue);
    }

    private void refresh() {
        jLabelCurrentValue.setText(estado.getFormatValue());
    }

    private void beep() {
        if (estado.beep == true) {
            playSound("beep1.wav");
        }
    }

    public synchronized void playSound(final String fileName) {
        new Thread(new Runnable() {

            public void run() {
                try {
                    Clip clip = AudioSystem.getClip();
                    AudioInputStream inputStream = AudioSystem.getAudioInputStream(new BufferedInputStream(this.getClass().getResourceAsStream(fileName)));

                    clip.open(inputStream);
                    clip.start();
                } catch (Exception e) {
                    System.err.println(e.getMessage());
                }
            }
        }).start();
    }

    /**
     * @return the minValue
     */
    public int getMinValue() {
        return estado.minValue;
    }

    /**
     * @param minValue the minValue to set
     */
    public void setMinValue(int minValue) {
        estado.minValue = minValue;
    }

    /**
     * @return the beep
     */
    public boolean isBeep() {
        return estado.beep;
    }

    /**
     * @param beep the beep to set
     */
    public void setBeep(boolean beep) {
        estado.beep = beep;
    }

    public void save() {
        String prefixProperties = "turno." + this.getName() + ".";

        Properties props = new Properties();
        try {
            props.load(new FileInputStream("turnos.properties"));
        } catch (IOException ex) {
            return;
        }
        props.setProperty(prefixProperties + "currentValue", String.valueOf(getCurrentValue()));
        props.setProperty(prefixProperties + "maxValue", String.valueOf(getMaxValue()));
        props.setProperty(prefixProperties + "minValue", String.valueOf(getMinValue()));
        props.setProperty(prefixProperties + "beep", String.valueOf(isBeep()));
        props.setProperty(prefixProperties + "fontSize", String.valueOf(getFontSize()));
        props.setProperty(prefixProperties + "description", getDescription());
        try {
            props.store(new FileOutputStream("turnos.properties"), "Propiedades de los turnos");
        } catch (IOException ex) {
            return;
        }
    }

    public void load() {
        String prefixProperties = "turno." + this.getName() + ".";

        Properties props = new Properties();
        try {
            props.load(new FileInputStream("turnos.properties"));
        } catch (IOException ex) {
            return;
        }
        if (props.getProperty(prefixProperties + "maxValue") != null) {
            estado.maxValue = Integer.parseInt(props.getProperty(prefixProperties + "maxValue"));
        }
        if (props.getProperty(prefixProperties + "currentValue") != null) {
            setCurrentValue(Integer.parseInt(props.getProperty(prefixProperties + "currentValue")));
        }
        if (props.getProperty(prefixProperties + "minValue") != null) {
            estado.minValue = Integer.parseInt(props.getProperty(prefixProperties + "minValue"));
        }
        if (props.getProperty(prefixProperties + "beep") != null) {
            estado.beep = Boolean.parseBoolean(props.getProperty(prefixProperties + "beep"));
        }
        if (props.getProperty(prefixProperties + "fontSize") != null) {
            setFontSize(Integer.parseInt(props.getProperty(prefixProperties + "fontSize")));
        }
        if (props.getProperty(prefixProperties + "description") != null) {
            setDescription(props.getProperty(prefixProperties + "description"));
        }
        refresh();
    }

    /**
     * @return the description
     */
    public String getDescription() {
        return estado.description;
    }

    /**
     * @param description the description to set
     */
    public void setDescription(String description) {
        estado.description = description;
        jLabelDescription.setText(description);
    }

    @Override
    public boolean isVisible() {
        return super.isVisible();
    }

    @Override
    public void setVisible(boolean visible) {
        super.setVisible(visible);
        estado.visible = visible;
    }

    class Estado {

        public int currentValue = 0;
        public int maxValue = 999;
        public int minValue = 0;
        public boolean beep = true;
        public String description = "";
        public boolean visible = true;

        public String getFormatValue() {
            StringBuffer sCurrentValue = new StringBuffer(currentValue + "");
            int len = String.valueOf(estado.maxValue).length();
            while (sCurrentValue.length() < len) {
                sCurrentValue.insert(0, "0");
            }

            return sCurrentValue.toString();
        }
    }
}
